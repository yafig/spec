# API Servers (Microservice)

The main microservice architecture is based on this Microsoft article: [Microsoft Microservices architecture style](https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices). HTTP REST API design is based on this Microsoft article: [Web API design](https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design).

## Service & Resource Definitions

The service definitions, resources and sub-resource, its endpoints and parameters.

There will be 3 main services in the system:

- [User Service](#User-Service)
- [Post Service](#Post-Service)
  - [Comment Subresource](#Comment-Sub-resource)
- [Search Service](#Search-Service)

### User Service

Handle user registration and authentication. User service will be accessible via both HTTP REST & gRPC. There is a small deviation from Microsoft API Design where username is being used as id in the URL path. The operations with HTTP REST are:

| Resource | POST | GET | PUT | DELETE |
|----------|------|-----|-----|--------|
| /register | Create a new user. Will publish a message to `send_email` queue | | | |
| /login | Login the user and return a JWT token | | | |
| /users | | Authenticate user based on Header Authorization supplied | | |
| /users/{username} | | Get user details | Update user | Delete user |
| /users/{username}/posts | | Get user's posts. Will invoke Post microservice. | | |
| /users/follow/{username} | | Creates a new record in `relationship` table and update `follow_count` of that user | | |
| /users/block/{username} | | Creates a new record in `relationship` table | | |

- `/users` is mainly for other microservices to authorize the current user in context.
- Follow and block operations will generate a materialized views in the database in the database to save the compute power during query. It will be bundled in the same database transaction.

### Post Service

Posts resource has a cascade subresource of Comments.

Post service will be accessible via both HTTP REST & gRPC. The operations with HTTP REST are:

- **GET** `/posts` -> `feed()`
- **GET** `/posts/{id}` -> `get_post(id)`
- **POST** `/posts/{id}` -> `upload(id)`

  After posting a new picture, the service will publish a message to: `thumbnail_generator` queue and `search_indexer` queue. The backend workers will perform tasks based on the message received
- **PUT** `/posts/{id}` -> `edit_post(id)`
- **DELETE** `/posts/{id}` -> `delete_post(id)`
- **GET** `/posts/users/{user_id}` -> `get_post_by_user(user_id)`

  This API call is for User service to invoke for its `/users/{username}/posts` endpoint.

The operations with gRPC are:

- `is_indexed(post_id)`
- `is_ready_thumbnail(post_id)`
- `delete_user(user_id)`

The gRPC protocol is mainly for the backend workers (`thumbnail_generator` and `search_indexer` workers) to update their progress.

### Comment Sub-resource

Search service is exposed via HTTP REST. The HTTP REST operation is:

- **GET** `/posts/{post_id}/comments/` -> `get_comment(post_id)`
- **POST** `/posts/{post_id}/comments/` -> `create_comment(post_id)`
- **PUT** `/posts/{post_id}/comments/{comment_id}` -> `edit_comment(post_id)`
- **DELETE** `/posts/{post_id}/comments/` -> `delete_comment(post_id)`
- **DELETE** `/posts/{post_id}/comments/{comment_id}` -> `delete_comment(post_id, comment_id)`

### Search Service

Search will be based on picture tag. 

Search service will be designed with **CQRS** design pattern. Its data is derived from Post database. It has its own dedicated database tailored for searching (eg. Elasticsearch). The database will be generated by [`search_index_builder` worker](https://github.com/yafig/spec/blob/master/backend.md#search_index_builder-worker).

Search service is exposed via HTTP REST. The HTTP REST operation is:

- **GET** `/search/query?query={query}&limit={limit}&offset={offset}` -> `search(query, limit, offset)`

  The `limit` and `offset` parameters are for the search result pagination.
- **GET** `/search/autocomplete?query={query}` -> `autocomplete(query)`

## Queues

These are the queues for communications between API Servers and Backend Workers.

- `search_indexer` queue: (create) post service -> queue -> search_indexer worker
- `thumbnail_generator` queue: (create) post service -> queue -> thumbnail_generator worker
- `send_email` queue: (create) user service -> queue -> send_email worker

## Implementations

The project will be implemented in both Go and Python. Both implementations are identical. It's just for me to learn both languages. Refer the API-Server repository for more information.

Across all services and both implementations, they will share the same specification:

- Logging format
- Caching using Redis
- Soft deletion
- API Documentation must be auto-generated
- Each endpoints will designed best to be idempotent
- ~~Use ORM to ensure portability between databases~~

The implementation of the microservice will be based on either of these architecture:

- [Flat-file](https://www.calhoun.io/flat-application-structure/)
- [Hexagonal / Port & Adapter Design](https://www.calhoun.io/moving-towards-domain-driven-design-in-go/)
- [Model-View-Controller (MVC)](https://www.calhoun.io/using-mvc-to-structure-go-web-applications/)

*\* Other useful resource to structure the microservice: https://www.youtube.com/watch?v=1rxDzs0zgcE*
